#pragma rtGlobals=3		// Use modern global access method.#include ":Utilities"#include ":FitFuncs"Function InitLinSim()	String savDF= GetDataFolder(1)	// Save current DF for restore.	if( DataFolderExists("root:WMLinSimData") )		SetDataFolder root:WMLinSimData	else 		NewDataFolder/S root:WMLinSimData	// Our stuff goes in here.	endif 	SetDataFolder savDF	// Restore current DF.EndFunction instantaneousFreq(beginfreq,endfreq,T1,t)	Variable beginfreq, endfreq, T1, t	Return 2*pi*(t*endfreq+(-1+Exp(-t/T1))*T1*(endfreq-beginfreq))EndFunction FID(beginfreq,endfreq,T1,t,w,td)// this is because we're modeling the actinic pump as a delta function// if we were to take into account the fact that it had some width then// we'd half to be more careful.	Variable beginfreq, endfreq, T1,td 	// tD is the delay between actinic and the probes (actinic is always at t=0)	WAVE w,t	variable phase,phase0,phasecorr	if(t<td)		//Before the actinic pump the mode is not being modulated		//return cos(2*pi*beginfreq*(t-t0))*conv_exp1(w,t)		return 0	else		//So we're creating a coherent vibration, the key word being COHERENT		//Thus the phase must be corrected so that the coherence is in phase (at least		//initially) with the Raman pump.		//Phase is the time-dependant phase		//phase0 is the value of the time dependant phase at t=0		//Phasecorr is the phase correction to ensure that the FID starts out in phase with the Raman pump		phase = instantaneousFreq(beginfreq,endfreq,T1,t-td)		phase0 = instantaneousFreq(beginfreq,endfreq,T1,-td)		phasecorr=2*pi*(phase0/(2*pi)-floor(phase0/(2*pi)))		return cos(phase-phasecorr)*conv_exp1(w,t)	endifEndFunction LinSim(paramWave,beginfreq,endfreq,T1,T2,scaleWave,name[,q])	//all times are in fs, frequencies in wavenumber and durations in gaussian widths, NOT FWHM	//and wavelengths in nm	// TMAx is the maximum amount of time in femtoseconds that you want to model the FID, so if you want to	// model the FID out to 5 ps this number should be 5000	//T1 is the time constant for the change in frequency and T2 is the FID decay time		WAVE/D paramWave, beginfreq,endfreq,T1,T2,scaleWave // Coefficient waves	String name // The wave that I want to return to the user	Variable q		//-------------------------------------------------------//	//Setting data folder to 	String savDF= GetDataFolder(1)	// Save current DF for restore.	if( DataFolderExists("root:WMLinSimData") )		SetDataFolder root:WMLinSimData	else 		NewDataFolder/S root:WMLinSimData	// Our stuff goes in here.	endif 	//-------------------------------------------------------//		//Gotta dump my parameters into named variables for my sanity	//The raman pump duration should be its FWHM in the time domain, which is then converted to a gaussian width	Variable durRpump=paramWave[0]/(2*sqrt(2*ln(2))	//The raman pump wavelength should be in nm	Variable rpumpwavelength=paramWave[1]	//Same for raman probe duration as raman pump	Variable durRprobe=paramWave[2]/(2*sqrt(2*ln(2))//user inputs FWHM	Variable tD=paramWave[3]//How long the FID should be modeled for and the delay between actinic and Raman		Variable length_c //coefficient wave length	If(numpnts(beginfreq)!=numpnts(endfreq) || numpnts(beginfreq)!=numpnts(T1) || numpnts(beginfreq)!=numpnts(T2) || numpnts(beginfreq)!=numpnts(scaleWave))		Print "Your coefficient waves must be the same length! Please check them and try again."		return -1 //Error	Else		length_c=numpnts(beginfreq)	Endif		variable timestep = 0.5//Gives a Nyquist frequency of 33333 wavenumbers	// which should be fine for most applications	If(ParamIsDefault(q))		q=0 //quiet or not quiet	Endif	If(q)		Print "######################################"		Print "#David Hoffman's Super Awesome Dispersive Lineshape Simulator!!!#"		Print "######################################"		Print " "		Print "Time zero (actinic pump) is at " + num2str(td)+" fs relative to the Raman probe"		Print " "	EndIf	if(q)		Print "My raman pump is " +num2str(durRpump*(2*sqrt(2*ln(2)))) + " fs long (FWHM)"		Print "My raman probe is " +num2str(durRprobe*(2*sqrt(2*ln(2)))) + " fs long (FWHM)"	EndIf	//Convert nm to inverse fs	variable rpfreq = 300/rpumpwavelength //assuming rpumpwavelength is given in nm	variable rprfreq = 300/(rpumpwavelength+10)	if(q)		Print "My Raman pump frequency is " + num2str(1e7/rpumpwavelength)+ " wavenumbers"			//A variable that determines the number of time steps taken		Print "I'm taking time steps of " + num2str(timestep)+" fs"		Print "The Nyquist frequency is " + num2str(1/(2*timestep*(3*10^(-5)))) +" wavenumbers"		Print " "		Print "-/-/-/-/-/-/-/-/-/-"		Print " "		//Make time waves		Print "Now I'm making my time waves"		Print " "		Print "Making my FID..."	EndIf	//IRF is not actually the instrument response time in the normal sense.	//This is because the vibrational coherence is only between the Raman pump and probe.	Variable IRF = paramWave[2]	Variable TMax=2*paramWave[0]		//How many points to make all my waves	Variable numPoints = ((Tmax+IRF*5)/timestep)	//Make an FID from -2000 fs until TMax	Make/D/O/N=(numPoints) times=timestep*x-IRF*5		//Make conv_exp1 parameter wave	Make/D/O/N=5 w={IRF,0,0,1,1000}		Make/D/O/N=(numPoints) FIDtemp=0		Variable i//index	For(i=0;i<length_c;i+=1)		//convert frequencies from wavenumbers to Hertz to inverse fs		variable bfreq=beginfreq[i]*3*10^(-5)		variable efreq=endfreq[i]*3*10^(-5)			//Make FID for vibrating normal mode		If(q)			Print "My beginning frequency is " + num2str(beginfreq[i])+" wavenumbers = "+num2str(bfreq)+ " inverse fs"			Print "My ending frequency is " + num2str(endfreq[i])+" wavenumbers = "+num2str(efreq)+ " inverse fs"			Print " "		EndIf				w={IRF,0,0,1,T2[i]}		FIDtemp+=scaleWave[i]*FID(bfreq,efreq,T1[i],times,w,tD)	EndFor		//Make FID for no Freqs	if(q)		Print "I finished my FID."	Endif		//Make Raman pump	If(q)		Print "Making my Raman Pump"	Endif	//I don't want a normalized gaussian	Make/D/o/n=(numPoints) rpump=gauss(times,0,durRpump)*sin(2*pi*rpfreq*times)		//Make raman probe	if(q)		Print "Making my Raman Probe"	EndIf	//The gaussian width is very small, to ensure that it is very broadband	Make/D/O/N=(numPoints) rprobe=gauss(times,0,1)*sin(2*pi*rprfreq*times)		//Make the total signal, RPump*FID + Rprobe	Make/D/O/N=(numPoints) toton=(rpump*(FIDtemp)+rprobe)	//Make the homodyne version of the signal	//Make/D/O/N=(numPoints) rpumpFID=rpump*FIDtemp	//Display toton vs times	if(q)		Print " "		//Take the FFT to get the frequency domain spectrum		Print "Taking the FFT's now..."	EndIf		//Of the everything on	FFT/OUT=4/PAD={262144}/DEST=toton_FFT toton		//Of everything off	FFT/OUT=4/PAD={262144}/DEST=totoff_FFT rprobe		//of the homodyne signal	//FFT/OUT=4/PAD={131072}/DEST=rpumpFID_FFT rpumpFID		//Of just the Raman pump and probe removing the noise created by the FID	if(q)		Print "Done  taking the FFT's."	EndIf		//Make the total signal Rpumpon/Rpumpoff	Duplicate/O toton_FFT root:$name	WAVE toReturn = root:$name	toReturn=(toReturn)/(totoff_FFT)		//Setting the scale to wavenumbers relative to Raman Pump	SetScale/P x, rpfreq/(3*10^(-5)), -1/(timestep*numpnts(toReturn)*2*3*10^(-5)),toReturn	//SetScale/P x, rpfreq/(3*10^(-5)), -1/(timestep*numpnts(toReturn)*2*3*10^(-5)),rpumpFID_FFT		if(q)		Print " "				Print "Displaying result"				Display toReturn		SetAxis bottom 0,2000		SetAxis/A=2 left				Print " "		Print "FIN"	EndIf		//Return to the original data folder	SetDataFolder savDF	// Restore current DF.		return 0EndFunction RunTimeLinSim(timepoints,paramWave,bf,ef,T1,T2,Scale,base)	WAVE timepoints,paramWave,bf,ef,T1,T2,Scale	String base	variable length=numpnts(timepoints),i		String currenttime		Variable t0		for(i=0;i<length;i+=1)		if(timepoints[i]<0)			currenttime=base+"m"+num2istr(abs(timepoints[i])) //this may need to be changed depending on the format of baseline_sub		else			currenttime=base+num2istr(timepoints[i])		endif		Print "Simulating "+num2istr(timepoints[i])		//Running LinSim 		paramWave[3]=-timepoints[i]				//Start timer		t0= ticks		LinSim(paramWave,bf,ef,T1,T2,scale,currenttime+"_sim")		printf "Elapsed time was %g seconds\r",(ticks-t0)/60		//End and print out timmer			EndForEndFunction RunTimeLinSim2(timepoints,packed_pW,base,shiftx)	WAVE timepoints,packed_pW,shiftx	String base	variable length=numpnts(timepoints),i		String currenttime		Variable t0		for(i=0;i<length;i+=1)		if(timepoints[i]<0)			currenttime=base+"m"+num2istr(abs(timepoints[i])) //this may need to be changed depending on the format of baseline_sub		else			currenttime=base+num2istr(timepoints[i])		endif		Print "Simulating "+num2istr(timepoints[i])		//Running LinSim 		packed_pW[3]=-timepoints[i]				Make/O/D/N=(numpnts(shiftx)) $(currenttime+"_sim")				//Start timer		t0= ticks		LinSimSub(packed_pW, $(currenttime+"_sim"),shiftx)		printf "Elapsed time was %g seconds\r",(ticks-t0)/60		//End and print out timmer			EndForEnd//The second version of these functions interlace the peaksFunction/S Packer(pW,bfW,efW,T1W,T2W,ScaleW,packName)	//A function to pack my parameters into a wave in order to use the all at once function	WAVE/D pW,bfW,efW,T1W,T2W,ScaleW	String PackName	//Some error checking	if(numpnts(pW)!= 4)		DoAlert 0, "Your core parameters are wrong"		Return ""	EndIf	//if(!(numpnts(bfW)== numpnts(efW)== numpnts(T1W)== numpnts(T2W)== numpnts(ScaleW)))		//	DoAlert 0, "All your parameter waves are not the same length"	//	Return ""	//EndIf	Make/D/O/N=(4+5*numpnts(bfW)) $packName = pW[p] //create a wave in which the first four	// Values are from pW	WAVE/D packed=$packName	variable i = 0	for(i=0;i<numpnts(bfW);i+=1)		packed[5*i+4] = scaleW[i]		packed[5*i+5] = bfW[i]		packed[5*i+6] = efW[i]		packed[5*i+7] = T1W[i]		packed[5*i+8] = T2W[i]	EndFor	Return  GetWavesDataFolder(packed,2)EndFunction UnPacker(pW)	WAVE pW	variable i = 0	Variable numPeaks = (numpnts(pW)-4)/5		Make/D/O/N=4 temp_pW = pW[x+i]		Make/D/O/N=(numPeaks) temp_bfW	Make/D/O/N=(numPeaks) temp_efW	Make/D/O/N=(numPeaks) temp_T1W	Make/D/O/N=(numPeaks) temp_T2W	Make/D/O/N=(numPeaks) temp_scaleW		For(i=0;i<numPeaks;i+=1)		temp_scaleW[i] = pW[5*i+4]		temp_bfW[i] = pW[5*i+5]		temp_efW[i] = pW[5*i+6]		temp_T1W[i] = pW[5*i+7]		temp_T2W[i] = pW[5*i+8]	EndForEndFunction LinSimSubBL(pW, yW, xW)	WAVE pW, yW, xW		Duplicate/O/R=[5,*] pW temp_pW		LinSimSub(temp_pW, yW, xW)		yW+= pW[1]+pW[2]*(xW-pW[0])+pW[3]*(xW-pW[0])^2+pW[4]*(xW-pW[0])^3EndFunction LinSimSub(pW, yW, xW)	//all times are in fs, frequencies in wavenumber and durations in gaussian widths, NOT FWHM	//and wavelengths in nm	// TMAx is the maximum amount of time in femtoseconds that you want to model the FID, so if you want to	// model the FID out to 5 ps this number should be 5000	//T1 is the time constant for the change in frequency and T2 is the FID decay time		WAVE pW, yW, xW		//-------------------------------------------------------//	//Setting data folder to 	String savDF= GetDataFolder(1)	// Save current DF for restore.	if( DataFolderExists("root:WMLinSimData") )		SetDataFolder root:WMLinSimData	else 		NewDataFolder/S root:WMLinSimData	// Our stuff goes in here.	endif 	//-------------------------------------------------------//		// Coefficient waves	UnPacker(pW)	WAVE paramWave = temp_pW	WAVE beginfreq = temp_bfW	WAVE endfreq = temp_efW	WAVE T1 = temp_T1W	WAVE T2 = temp_T2W	WAVE scaleWave = temp_scaleW		//Gotta dump my parameters into named variables for my sanity	//The raman pump duration should be its FWHM in the time domain, which is then converted to a gaussian width	Variable durRpump=paramWave[0]/(2*sqrt(2*ln(2))	//The raman pump wavelength should be in nm	Variable rpumpwavelength=paramWave[1]	//Same for raman probe duration as raman pump	Variable durRprobe=paramWave[2]/(2*sqrt(2*ln(2))//user inputs FWHM	Variable tD=paramWave[3]//How long the FID should be modeled for and the delay between actinic and Raman		variable timestep = 0.5//Gives a Nyquist frequency of 33333 wavenumbers	// which should be fine for most applications		//Convert nm to inverse fs	variable rpfreq = 300/rpumpwavelength //assuming rpumpwavelength is given in nm	variable rprfreq = 300/(rpumpwavelength+10)		//IRF is not actually the instrument response time in the normal sense.	//This is because the vibrational coherence is only between the Raman pump and probe.	Variable IRF = paramWave[2]	Variable TMax=2*paramWave[0]		//How many points to make all my waves	Variable numPoints = ((Tmax+IRF*5)/timestep)	//Make an FID from -2000 fs until TMax	Make/D/O/N=(numPoints) times=timestep*x-IRF*5		//Make conv_exp1 parameter wave	Make/D/O/N=5 w={IRF,0,0,1,1000}		Make/D/O/N=(numPoints) FIDtemp=0		Variable i//index	For(i=0;i<numPnts(endfreq);i+=1)		//convert frequencies from wavenumbers to Hertz to inverse fs		variable bfreq=beginfreq[i]*3*10^(-5)		variable efreq=endfreq[i]*3*10^(-5)			//Make FID for vibrating normal mode		w={IRF,0,0,1,T2[i]}		FIDtemp+=scaleWave[i]*FID(bfreq,efreq,T1[i],times,w,tD)	EndFor		//Make Raman pump	Make/D/O/N=(numPoints) rpump=gauss(times,0,durRpump)*sin(2*pi*rpfreq*times)		//Make raman probe	//The gaussian width is very small, to ensure that it is very broadband	Make/D/O/N=(numPoints) rprobe=gauss(times,0,1)*sin(2*pi*rprfreq*times)		//Make the total signal, RPump*FID + Rprobe	Make/D/O/N=(numPoints) toton=(rpump*(FIDtemp)+rprobe)		//Take FFT of the everything on	FFT/OUT=4/PAD={262144}/DEST=toton_FFT toton		//Of everything off	FFT/OUT=4/PAD={262144}/DEST=totoff_FFT rprobe		//Make the total signal Rpumpon/Rpumpoff	Duplicate/O toton_FFT tempSimWave	tempSimWave=(tempSimWave)/(totoff_FFT)		//Setting the scale to wavenumbers relative to Raman Pump	SetScale/P x, rpfreq/(3*10^(-5)), -2/(timestep*262144*2*3*10^(-5)),tempSimWave	//Place the result into yW and subtract 1	yW=tempSimWave(xW[p])-1	//Return to the original data folder	SetDataFolder savDF	// Restore current DF.		return 0End